
<h1>方法</h1>

```
/*
 *创建一个对象
*/
var obj=new Object();

//向对象中添加属性
obj.name="孙悟空";
obj.age=18;

//对象的属性值可以是任何的数据类型，也可以是一个函数
obj.sayName=function(){
    console.log(obj.name);
};

function fun(){
    console.log(obj.name);
};

//console.log(obj.sayName);
//调方法
obj.sayName();

//调函数
fun();

/*
 *函数也可以称为对象的属性
 *  如果一个函数作为一个对象的属性保存
 *  那么我们称这个函数是这个对象的方法
 *  调用这个函数就说明调用对象的方法（method）

 *  但是它只是名称上的区别没有其他的区别
 */


 var obj2={
     name:"猪八戒",
     age:18,
     sayName:funtion(){
         console.log(obj2.name);
     }
 };
 obj2.sayName();
```

<h1>枚举对象中的属性</h1>

```
var obj={
    name:"孙悟空",
    age:18,
    gender:"男",
    address:"花果山"
}

//枚举对象中的属性
//使用for....in语句

/*
 * 语法：
 *     for(var 变量in 对象){

 }
 
 *for...in语句对象中有几个属性，循环体就会执行几次
 *  每次执行时，会将对象中的一个属性的名字赋值给变量
*/

for(var n in obj){
    console.log("属性值："+n);
    console.log("属性值：" +obj[n]);
}
```
<h1>作用域</h1>

/*作用域
 *   - 作用域指一个变量的作用的范围
 *   - 在JS中一共有两种作用域
 *        1.全局作用域
 *         - 直接编写在script标签中的JS代码，都在全局作用
 *         - 全局作用域在页面打开时创建，在页面关闭时销毁
 *         - 在全局作用域中有一个全局对象window
                它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用
           - 在全局作用域中
                创建的变量都会作为window对象的属性保存
 *              创建的函数都会作为window对象的方法
 *         - 全局作用域的变量都是全局变量
 *               在页面的任意部分都可以访问的到

 *        2.函数作用域
*/

```
var a=10;
var b=20;
console.log(window.b);
```

```
function fun(){
    console.log("我是fun函数");
}
window.fun();

//window.alert("hello");
```
<h1>变量的声明提前</h1>

/*
 * 变量的声明提前
 *    - 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值）
 *          但是如果声明变量时不适用var关键字，则变量不会被声明提前
 *    - 使用函数声明形式创建的函数function 函数(){}
 *          它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数
 * 使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用

*/
```
var a=123;//等于winodw.a=123//a=123;
console.log("a="+a);
```

```
//函数声明，会被提前创建
function fun(){
    console.log("我是一个fun函数");
}

//函数表达式，不会被提前创建
var fun2 =function(){
    console.log("我是fun2函数");
};

fun();
fun2();
```
<h1>函数作用域</h1>

/* 
 * 函数作用域
 * -  调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁
 * -  每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的
 * -  在函数作用域中可以访问到全局作用域变量（局部可以访问到全局）
 * -  在全局作用域中无法访问到函数作用域的变量（全局无法访问到局部）
 * -  当在函数作用操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有就向上一级中寻找,直到找到全局作用域
 * -  如果全局作用域中依然没有找到，则会报错ReferenceError
 * -  在函数中要访问全局变量可以使用window对象
* /  

```
//创建一个变量
var a=10;
function fun(){

    var a="我是fun函数中的变量a";
    var b=20;
  //console.log("a"= +a);

  function fun2(){
      console.log("a=" +window.a);
  }
  fun2();
}
fun();
//console.log("b=" +b);
//console.log("a=" +a);
```

/*
 *  在函数作用域也有声明提前的特性
 *    使用var关键字声明的变量，会在函数中所有的代码执行之前被声明
 *    函数声明也会在函数中所有的代码执行之前执行
 
*/

```
funciton fun3(){
    fun4();

    var a;
    console.log(a);//结果undefined
    a=35;

    function fun4(){
        alert("我是fun4");
    }
}
fun3();
```

/*
 * - 在函数中，不适用var声明的变量都会成为全局变量

*/

```
var c=33;
function fun5(){
    console.log("c=" +c);
     //c=10;

     //d没有使用var关键字，则会设置为全局变量
     d=100;//等于 window.d=100;
}
fun5();

//在全局输出C
console.log("d=" +d);
```

/*
 * 定义形参就相当于在函数作用域中声明了变量

*/

```
var e=23;
function fun6(e){
    alert(e);
}
fun6();
```
<h1>debug（调试）</h1>

<h1>this</h1>

/*
 * 解析器在调用函数每次都会向函数内部传递一个隐含的参数
 * 这个隐含的参数就是this,this指向的是一个对象，这个对象我们称为函数执行的上下文对象
 * 根据函数的调用方式不同，this会指向不同的对象
 *        1.以函数的形式调用时，this永远都是window
 *        2.以方法的形式调用时，this就是调用方法的那个对象
*/

```
function fun(a,b){
    //console.log("a="+a",b=" +b);
    console.log(this.name);
}
fun();

//创建一个对象
var obj={
    name:"孙悟空",
    sayName:fun
};
var obj2={
    name:"沙和尚",
    sayName:fun
};

//console.log(obj.sayName==fun);
var name="全局的name属性";
//obj2.sayName();//结果：object

//以函数形式调用，this是window
fun();

//以方法的形式调用,this是调用方法的对象
//obj.sayName();
obj2.sayName();
```

```
//创建一个name变量
 var name="全局";

//创建一个fun()函数
function fun(){
    console.log(this.name);
}
//创建两个对象
var obj={
    name:"孙悟空",
    sayName:fun
};
var obj2={
    name:"沙和尚",
    sayName:fun
};

//我们希望调用obj.sayName()时可以输出obj的名字
//obj.sayName();

obj2.sayName();
```
